/*
Author: randomstr1ng
Description: This file contains the implementation of the decryption algorithm for SAP GUI history.
*/
#include <iostream>
#include <string>
#include <algorithm>
#include <cctype>
#include <windows.h>
#include <wincrypt.h>
#include <lmcons.h>
#include <vector>
#include <iomanip>
#include <sstream>

#pragma comment(lib, "Advapi32.lib")
#define MS_BASE_CRYPTO_PROVIDER_A "Microsoft Base Cryptographic Provider v1.0"

struct CryptographicContext {
    HCRYPTPROV hCryptProv;
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;
    BOOL status;
    DWORD lastError;
    char dataBuffer[100];
};

// Username transformation function
std::string process_and_send_data(const std::string& input_data) {
    const int MAX_ITERATIONS = 0x13; // 19 in decimal
    std::string buffer;

    for (size_t i = 0; i < input_data.length() && i < MAX_ITERATIONS; ++i) {
        char input_char = input_data[i];
        int transformed = ((input_char + i) % 26) + 0x41;
        buffer += static_cast<char>(transformed);
    }

    return buffer;
}
// Convert hex string to bytes
size_t hex_string_to_bytes(const std::string& hex_str, std::vector<BYTE>& bytes) {
    bytes.clear();
    size_t len = hex_str.length();

    for (size_t i = 0; i < len; i += 2) {
        char high = toupper(hex_str[i]) - '0';
        if (high > 9) high -= 7;

        char low = toupper(hex_str[i + 1]) - '0';
        if (low > 9) low -= 7;

        BYTE value = (high << 4) | low;
        if (value > 0xFF) value = 0;

        bytes.push_back(value);
    }

    return bytes.size();
}

// Convert bytes to hex string
std::string bytes_to_hex(const std::vector<BYTE>& data) {
    std::stringstream ss;
    for (BYTE b : data) {
        ss << std::uppercase << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(b);
    }
    return ss.str();
}

bool create_encryption_key(CryptographicContext* ctx, const char* transformed_username) {
    ctx->status = TRUE;

    if (ctx->hCryptProv == 0) {
        ctx->status = CryptAcquireContextA(
            &ctx->hCryptProv,
            nullptr,
            MS_BASE_CRYPTO_PROVIDER_A,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT
        );
    }

    if (ctx->status && ctx->hHash != 0) {
        ctx->status = CryptDestroyHash(ctx->hHash);
        ctx->hHash = 0;
    }

    if (ctx->status && ctx->hHash == 0) {
        ctx->status = CryptCreateHash(
            ctx->hCryptProv,
            CALG_MD5,
            0,
            0,
            &ctx->hHash
        );
    }

    if (ctx->status) {
        DWORD dataLen = static_cast<DWORD>(strlen(transformed_username));
        ctx->status = CryptHashData(
            ctx->hHash,
            (const BYTE*)transformed_username,
            dataLen,
            0
        );
    }

    if (ctx->status) {
        ctx->status = CryptDeriveKey(
            ctx->hCryptProv,
            CALG_RC4,
            ctx->hHash,
            1,
            &ctx->hKey
        );
    }

    if (!ctx->status) {
        ctx->lastError = GetLastError();
        std::cerr << "[-] Error creating encryption key. Error code: " << ctx->lastError << std::endl;
    }

    return ctx->status != 0;
}
// Decrypt data
bool decrypt_data(CryptographicContext* ctx, const std::string& hex_input, std::string& output) {
    if (!ctx->hKey) {
        std::cerr << "[-] No encryption key available" << std::endl;
        return false;
    }

    std::vector<BYTE> encrypted_data;
    hex_string_to_bytes(hex_input, encrypted_data);

    DWORD dataLen = static_cast<DWORD>(encrypted_data.size());

    if (!CryptDecrypt(ctx->hKey, 0, TRUE, 0, encrypted_data.data(), &dataLen)) {
        std::cerr << "[-] Decryption failed. Error: " << GetLastError() << std::endl;
        return false;
    }

    // Convert decrypted data to string, stopping at null terminator if present
    output = std::string(reinterpret_cast<char*>(encrypted_data.data()));
    return true;
}
// Encrypt data
bool encrypt_data(CryptographicContext* ctx, const std::string& input, std::string& hex_output) {
    if (!ctx->hKey) {
        std::cerr << "[-] No encryption key available" << std::endl;
        return false;
    }

    std::vector<BYTE> data(input.begin(), input.end());
    DWORD dataLen = static_cast<DWORD>(data.size());

    // Add padding for block cipher if necessary (not required for RC4)
    if (!CryptEncrypt(ctx->hKey, 0, TRUE, 0, data.data(), &dataLen, static_cast<DWORD>(data.capacity()))) {
        std::cerr << "[-] Encryption failed. Error: " << GetLastError() << std::endl;
        return false;
    }

    hex_output = bytes_to_hex(data);
    return true;
}
int main(int argc, char* argv[]) {
    if (argc < 2 || _stricmp(argv[1], "/h") == 0) {
        std::cout << "Usage:\n";
        std::cout << " /e <plaintext>   Encrypt string to hex\n";
        std::cout << " /d <hexstring>   Decrypt hex string to plaintext\n";
        std::cout << " /h               Show this help message\n";
        return 0;
    }

    std::string mode = argv[1];
    std::string input_data = (argc >= 3) ? argv[2] : "";

    if ((mode == "/e" || mode == "/d") && input_data.empty()) {
        std::cerr << "[-] Error: Missing input data for " << mode << " mode.\n";
        return 1;
    }

    char username[UNLEN + 1];
    DWORD username_len = UNLEN + 1;
    CryptographicContext ctx = { 0 };

    if (!GetUserNameA(username, &username_len)) {
        std::cerr << "[-] Failed to get username. Error code: " << GetLastError() << std::endl;
        return 1;
    }

    std::string username_str(username);
    std::transform(username_str.begin(), username_str.end(), username_str.begin(), ::toupper);
    std::string transformed_username = process_and_send_data(username_str);

    std::cout << "[+] windows username: " << username_str << std::endl;
    std::cout << "[+] transformed username: " << transformed_username << std::endl;

    if (!create_encryption_key(&ctx, transformed_username.c_str())) {
        std::cerr << "[-] Failed to create encryption key\n";
        return 1;
    }

    if (mode == "/e") {
        std::string encrypted_hex;
        if (encrypt_data(&ctx, input_data, encrypted_hex)) {
            std::cout << "[+] encrypted hex: " << encrypted_hex << std::endl;
        }
    } else if (mode == "/d") {
        std::string decrypted_output;
        if (decrypt_data(&ctx, input_data, decrypted_output)) {
            std::cout << "[+] decrypted data: " << decrypted_output << std::endl;
        }
    } else {
        std::cerr << "[-] Unknown mode: " << mode << "\n";
        return 1;
    }

    // Cleanup
    if (ctx.hKey) CryptDestroyKey(ctx.hKey);
    if (ctx.hHash) CryptDestroyHash(ctx.hHash);
    if (ctx.hCryptProv) CryptReleaseContext(ctx.hCryptProv, 0);

    return 0;
}
